# Function类型

* function类型也是对象，每一个函数都是Funcction类型的实例，而且与其他引用一样具有属性和方法
* 创建函数的三种方式
  * 使用函数声明语法定义
    * ```
      funcion funcName (params) {

      }
      ```
  * 使用函数表达式定义

    * ```
      var sum  = function (params) {

      }
      ```

  * 使用new Function（\)创建，最后一个参数为函数，前面的参数为函数的参数。此种方法不推荐使用
* 函数名其实仅仅只是指向函数的指针，因此函数名与包含对象指针的其它变量没什么区别

* **为什么js没有重载**

  * 因为函数其实也是对象，定义两个同名的函数等同于将函数变量名重新赋值一个函数。

    * ```
      function func1 (number1) { return number1+1}
      function func1 (number1) {return number1+2}
      //等同于
      function func1 () {}
      func1 = function (){}
      改变了func1指向的内存空间，自然没有函数重载这一实现
      ```

* **函数声明提升**

  * 函数以函数声明方式创建时，解析器会预先解析函数，以便于在其他地方使用时，可以正确执行

  * 但是如果是以表达式的形式创建的函数，那么不会被提升到代码树的顶端

* 作为值的函数

  * 因为函数是对象，所以函数可以作为参数其他的函数，也可以作为返回值被其他函数reurn出来

* 函数内部的属性

  * arguments 存放传入的参数，是一个伪数组对象

    * 内部有一个callee指针属性，指向拥有arguments对象的函数对象，这在递归函数中sh用比较方便

  * this 指当前的执行环境对象

    * this的值在函数体中定义时并不确定，当函数调用时，才能判断this准确的值！！！

* 函数的属性和方法

  * 属性

    * length

      * 表示函数希望接受的参数的个数，在定义函数时定义的参数个数

    * prototype 原型

  * 方法

    * apply\(\) 接受一个指定的执行环境对象，和一个数组参数（也可以是arguments对象）

    * call\(\) 和apply效果相同，只是参数的传递方式不同，call传递参数时，参数必须一项一项的列举出来。

    * apply和call方法的最大作用扩展函数运行的作用域，修改函数中的this值来改变运行的执行环境

    * bind（object） 函数调用bind方法会创建一个函数实例，其this值会被绑定在传入的object

    * toString\(\) toLoalString\(\) valueOf\(\)都会返回函数的代码



